// This file is @generated by prost-build.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestEvaluationDetail {
    #[prost(enumeration = "TestOutcome", tag = "1")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<TestOutcome>(&::fake::Faker) as i32")
    )]
    pub test_outcome: i32,
    /// Number of failing rows for this test.
    #[prost(int32, tag = "2")]
    pub failing_rows: i32,
    /// Pretty printed table diff if available.
    #[prost(string, optional, tag = "4")]
    pub diff_table: ::core::option::Option<::prost::alloc::string::String>,
}
impl crate::StaticName for TestEvaluationDetail {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.TestEvaluationDetail";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.TestEvaluationDetail";
}
impl ::prost::Name for TestEvaluationDetail {
    const NAME: &'static str = "TestEvaluationDetail";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.TestEvaluationDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.TestEvaluationDetail".into()
    }
}
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourceFreshnessDetail {
    #[prost(enumeration = "SourceFreshnessOutcome", tag = "1")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "::fake::Fake::fake::<SourceFreshnessOutcome>(&::fake::Faker) as i32"
        )
    )]
    pub node_freshness_outcome: i32,
}
impl crate::StaticName for SourceFreshnessDetail {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.SourceFreshnessDetail";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.SourceFreshnessDetail";
}
impl ::prost::Name for SourceFreshnessDetail {
    const NAME: &'static str = "SourceFreshnessDetail";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.SourceFreshnessDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.SourceFreshnessDetail".into()
    }
}
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeCacheDetail {
    #[prost(enumeration = "NodeCacheReason", tag = "1")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<NodeCacheReason>(&::fake::Faker) as i32")
    )]
    pub node_cache_reason: i32,
    /// If node_cache_reason == NODE_CACHE_REASON_STILL_FRESH, this field indicates
    /// freshness period for this node in seconds.
    #[prost(uint64, optional, tag = "2")]
    pub build_after_seconds: ::core::option::Option<u64>,
    /// If node_cache_reason == NODE_CACHE_REASON_STILL_FRESH, this field indicates
    /// time since last update in seconds.
    #[prost(uint64, optional, tag = "3")]
    pub last_updated_seconds: ::core::option::Option<u64>,
}
impl crate::StaticName for NodeCacheDetail {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.NodeCacheDetail";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.NodeCacheDetail";
}
impl ::prost::Name for NodeCacheDetail {
    const NAME: &'static str = "NodeCacheDetail";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.NodeCacheDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.NodeCacheDetail".into()
    }
}
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeSkipUpstreamDetail {
    /// unique_id of the upstream node that caused this node to be skipped.
    #[prost(string, tag = "1")]
    pub upstream_unique_id: ::prost::alloc::string::String,
}
impl crate::StaticName for NodeSkipUpstreamDetail {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.NodeSkipUpstreamDetail";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.NodeSkipUpstreamDetail";
}
impl ::prost::Name for NodeSkipUpstreamDetail {
    const NAME: &'static str = "NodeSkipUpstreamDetail";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.NodeSkipUpstreamDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.NodeSkipUpstreamDetail".into()
    }
}
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeEvaluated {
    /// unique_id is the globally unique identifier for this node.
    #[prost(string, tag = "1")]
    pub unique_id: ::prost::alloc::string::String,
    /// Node name.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Database where this node will be created if applicable.
    #[prost(string, optional, tag = "3")]
    pub database: ::core::option::Option<::prost::alloc::string::String>,
    /// Schema where this node will be created if applicable.
    #[prost(string, optional, tag = "4")]
    pub schema: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the relation (table, view, etc.) that will be created for this node if applicable.
    #[prost(string, optional, tag = "5")]
    pub identifier: ::core::option::Option<::prost::alloc::string::String>,
    /// How this node is materialized in the data warehouse.
    #[prost(enumeration = "NodeMaterialization", optional, tag = "7")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "Some(::fake::Fake::fake::<NodeMaterialization>(&::fake::Faker) as i32)"
        )
    )]
    pub materialization: ::core::option::Option<i32>,
    /// If materialization == NODE_MATERIALIZATION_CUSTOM, this field contains the custom materialization name.
    #[prost(string, optional, tag = "8")]
    pub custom_materialization: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of node being evaluated. Known as `resource_type` in dbt core.
    #[prost(enumeration = "NodeType", tag = "9")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<NodeType>(&::fake::Faker) as i32")
    )]
    pub node_type: i32,
    /// Core outcome for this evaluation.
    #[prost(enumeration = "NodeOutcome", tag = "10")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<NodeOutcome>(&::fake::Faker) as i32")
    )]
    pub node_outcome: i32,
    /// Execution phase during which this node was evaluated.
    #[prost(enumeration = "super::phase::ExecutionPhase", tag = "11")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "::fake::Fake::fake::<super::phase::ExecutionPhase>(&::fake::Faker) as i32"
        )
    )]
    pub phase: i32,
    /// Relative path to the file containing node definition within the dbt project.
    #[prost(string, tag = "12")]
    pub relative_path: ::prost::alloc::string::String,
    /// Line number (1-indexed) where the test is defined (only applicable to test nodes)
    #[prost(uint32, optional, tag = "13")]
    pub defined_at_line: ::core::option::Option<u32>,
    /// Column number (0-indexed) of where the test is defined (only applicable to test nodes)
    #[prost(uint32, optional, tag = "14")]
    pub defined_at_col: ::core::option::Option<u32>,
    /// Checksum of the node definition
    #[prost(string, tag = "15")]
    pub node_checksum: ::prost::alloc::string::String,
    /// Whether or not SAO was enabled for this node during evaluation. Only set for run phase.
    #[prost(bool, optional, tag = "16")]
    pub sao_enabled: ::core::option::Option<bool>,
    /// Categorization of aggregated errors for debugging and retry logic.
    /// Present when node_outcome == NODE_OUTCOME_ERROR.
    #[prost(enumeration = "NodeErrorType", optional, tag = "20")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "Some(::fake::Fake::fake::<NodeErrorType>(&::fake::Faker) as i32)")
    )]
    pub node_error_type: ::core::option::Option<i32>,
    /// Cancellation reason.
    /// Present when node_outcome == NODE_OUTCOME_CANCELED.
    #[prost(enumeration = "NodeCancelReason", optional, tag = "21")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "Some(::fake::Fake::fake::<NodeCancelReason>(&::fake::Faker) as i32)"
        )
    )]
    pub node_cancel_reason: ::core::option::Option<i32>,
    /// Detailed reason for skipping this node.
    /// Present when node_outcome == NODE_OUTCOME_SKIPPED.
    #[prost(enumeration = "NodeSkipReason", optional, tag = "22")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "Some(::fake::Fake::fake::<NodeSkipReason>(&::fake::Faker) as i32)")
    )]
    pub node_skip_reason: ::core::option::Option<i32>,
    /// Optional legacy dbt core event code (e.g. "Q018") if this event has a strict mapping to a dbt core event.
    #[prost(string, optional, tag = "40")]
    pub dbt_core_event_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Node type specific details (e.g. test fail counts, cache use reasons).
    #[prost(oneof = "node_evaluated::NodeOutcomeDetail", tags = "30, 31, 32, 33")]
    pub node_outcome_detail: ::core::option::Option<node_evaluated::NodeOutcomeDetail>,
}
/// Nested message and enum types in `NodeEvaluated`.
pub mod node_evaluated {
    /// Node type specific details (e.g. test fail counts, cache use reasons).
    #[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
    #[derive(::serde::Serialize, ::serde::Deserialize)]
    #[cfg_attr(any(test, feature = "test-utils"), derive(::strum::EnumIter))]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum NodeOutcomeDetail {
        /// Detailed reason why cache was used.
        /// Present when node_skip_reason == NODE_SKIP_REASON_CACHED.
        #[prost(message, tag = "30")]
        NodeCacheDetail(super::NodeCacheDetail),
        /// Test specific outcome details.
        /// Present for test / unit test node types when node_outcome == NODE_OUTCOME_SUCCESS.
        #[prost(message, tag = "31")]
        NodeTestDetail(super::TestEvaluationDetail),
        /// Source freshness specific outcome details.
        /// Present for source nodes with freshness checks when node_outcome == NODE_OUTCOME_SUCCESS.
        #[prost(message, tag = "32")]
        NodeFreshnessOutcome(super::SourceFreshnessDetail),
        /// Upstream node that caused this node to be skipped.
        /// Present when node_skip_reason == NODE_SKIP_REASON_UPSTREAM.
        #[prost(message, tag = "33")]
        NodeSkipUpstreamDetail(super::NodeSkipUpstreamDetail),
    }
}
impl crate::StaticName for NodeEvaluated {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.NodeEvaluated";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.NodeEvaluated";
}
impl ::prost::Name for NodeEvaluated {
    const NAME: &'static str = "NodeEvaluated";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.NodeEvaluated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.NodeEvaluated".into()
    }
}
/// Span event tracking full processing of a node across all phases.
/// Supersedes legacy NodeStart (Q024) and NodeFinished (Q025) events.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoNew)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeProcessed {
    /// unique_id is the globally unique identifier for this node.
    #[prost(string, tag = "1")]
    pub unique_id: ::prost::alloc::string::String,
    /// Node name.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Database where this node will be created if applicable.
    #[prost(string, optional, tag = "3")]
    pub database: ::core::option::Option<::prost::alloc::string::String>,
    /// Schema where this node will be created if applicable.
    #[prost(string, optional, tag = "4")]
    pub schema: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the relation (table, view, etc.) that will be created for this node if applicable.
    #[prost(string, optional, tag = "5")]
    pub identifier: ::core::option::Option<::prost::alloc::string::String>,
    /// How this node is materialized in the data warehouse.
    #[prost(enumeration = "NodeMaterialization", optional, tag = "7")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "Some(::fake::Fake::fake::<NodeMaterialization>(&::fake::Faker) as i32)"
        )
    )]
    pub materialization: ::core::option::Option<i32>,
    /// If materialization == NODE_MATERIALIZATION_CUSTOM, this field contains the custom materialization name.
    #[prost(string, optional, tag = "8")]
    pub custom_materialization: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of node being evaluated. Known as `resource_type` in dbt core.
    #[prost(enumeration = "NodeType", tag = "9")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<NodeType>(&::fake::Faker) as i32")
    )]
    pub node_type: i32,
    /// Core outcome for this node processing across all phases.
    #[prost(enumeration = "NodeOutcome", tag = "10")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<NodeOutcome>(&::fake::Faker) as i32")
    )]
    pub node_outcome: i32,
    /// Last execution phase that was reached during processing (or would have been reached if not skipped).
    #[prost(enumeration = "super::phase::ExecutionPhase", tag = "11")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "::fake::Fake::fake::<super::phase::ExecutionPhase>(&::fake::Faker) as i32"
        )
    )]
    pub last_phase: i32,
    /// Relative path to the file containing node definition within the dbt project.
    #[prost(string, tag = "12")]
    pub relative_path: ::prost::alloc::string::String,
    /// Line number (1-indexed) where the test is defined (only applicable to test nodes)
    #[prost(uint32, optional, tag = "13")]
    pub defined_at_line: ::core::option::Option<u32>,
    /// Column number (0-indexed) of where the test is defined (only applicable to test nodes)
    #[prost(uint32, optional, tag = "14")]
    pub defined_at_col: ::core::option::Option<u32>,
    /// Checksum of the node definition
    #[prost(string, tag = "15")]
    pub node_checksum: ::prost::alloc::string::String,
    /// Whether or not SAO was enabled for this node during evaluation. Only set for invocations,
    /// that include the run phase.
    #[prost(bool, optional, tag = "16")]
    pub sao_enabled: ::core::option::Option<bool>,
    /// Categorization of aggregated errors for debugging and retry logic.
    /// Present when node_outcome == NODE_OUTCOME_ERROR.
    #[prost(enumeration = "NodeErrorType", optional, tag = "20")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "Some(::fake::Fake::fake::<NodeErrorType>(&::fake::Faker) as i32)")
    )]
    pub node_error_type: ::core::option::Option<i32>,
    /// Cancellation reason.
    /// Present when node_outcome == NODE_OUTCOME_CANCELED.
    #[prost(enumeration = "NodeCancelReason", optional, tag = "21")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(
            expr = "Some(::fake::Fake::fake::<NodeCancelReason>(&::fake::Faker) as i32)"
        )
    )]
    pub node_cancel_reason: ::core::option::Option<i32>,
    /// Detailed reason for skipping this node.
    /// Present when node_outcome == NODE_OUTCOME_SKIPPED.
    #[prost(enumeration = "NodeSkipReason", optional, tag = "22")]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "Some(::fake::Fake::fake::<NodeSkipReason>(&::fake::Faker) as i32)")
    )]
    pub node_skip_reason: ::core::option::Option<i32>,
    /// Legacy dbt core event code. Always set to Q024 for start, Q025 for end.
    #[prost(string, tag = "40")]
    pub dbt_core_event_code: ::prost::alloc::string::String,
    /// Total duration in milliseconds of all nested NodeEvaluated spans.
    /// This reflects the actual time spent processing the node, excluding time
    /// waiting for upstream nodes.
    #[prost(uint64, optional, tag = "41")]
    pub duration_ms: ::core::option::Option<u64>,
    /// Some node's maybe be anaklyzed but not selected for execution. This flag indicates
    /// whether the node was in the selection set.
    #[prost(bool, tag = "42")]
    pub in_selection: bool,
    /// Node type specific details (e.g. test fail counts, cache use reasons).
    #[prost(oneof = "node_processed::NodeOutcomeDetail", tags = "30, 31, 32, 33")]
    pub node_outcome_detail: ::core::option::Option<node_processed::NodeOutcomeDetail>,
}
/// Nested message and enum types in `NodeProcessed`.
pub mod node_processed {
    /// Node type specific details (e.g. test fail counts, cache use reasons).
    #[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
    #[derive(::serde::Serialize, ::serde::Deserialize)]
    #[cfg_attr(any(test, feature = "test-utils"), derive(::strum::EnumIter))]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum NodeOutcomeDetail {
        /// Detailed reason why cache was used.
        /// Present when node_skip_reason == NODE_SKIP_REASON_CACHED.
        #[prost(message, tag = "30")]
        NodeCacheDetail(super::NodeCacheDetail),
        /// Test specific outcome details.
        /// Present for test / unit test node types when node_outcome == NODE_OUTCOME_SUCCESS.
        #[prost(message, tag = "31")]
        NodeTestDetail(super::TestEvaluationDetail),
        /// Source freshness specific outcome details.
        /// Present for source nodes with freshness checks when node_outcome == NODE_OUTCOME_SUCCESS.
        #[prost(message, tag = "32")]
        NodeFreshnessOutcome(super::SourceFreshnessDetail),
        /// Upstream node that caused this node to be skipped.
        /// Present when node_skip_reason == NODE_SKIP_REASON_UPSTREAM.
        #[prost(message, tag = "33")]
        NodeSkipUpstreamDetail(super::NodeSkipUpstreamDetail),
    }
}
impl crate::StaticName for NodeProcessed {
    const FULL_NAME: &'static str = "v1.public.events.fusion.node.NodeProcessed";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.node.NodeProcessed";
}
impl ::prost::Name for NodeProcessed {
    const NAME: &'static str = "NodeProcessed";
    const PACKAGE: &'static str = "v1.public.events.fusion.node";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.node.NodeProcessed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.node.NodeProcessed".into()
    }
}
/// Node type, also known as "resource type" in dbt core.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeType {
    Unspecified = 0,
    Model = 1,
    Seed = 2,
    Snapshot = 11,
    Source = 3,
    Test = 4,
    UnitTest = 5,
    Macro = 6,
    DocsMacro = 7,
    Analysis = 8,
    Operation = 9,
    Exposure = 10,
    Metric = 12,
    SavedQuery = 13,
    SemanticModel = 14,
    Function = 15,
}
impl NodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_TYPE_UNSPECIFIED",
            Self::Model => "NODE_TYPE_MODEL",
            Self::Seed => "NODE_TYPE_SEED",
            Self::Snapshot => "NODE_TYPE_SNAPSHOT",
            Self::Source => "NODE_TYPE_SOURCE",
            Self::Test => "NODE_TYPE_TEST",
            Self::UnitTest => "NODE_TYPE_UNIT_TEST",
            Self::Macro => "NODE_TYPE_MACRO",
            Self::DocsMacro => "NODE_TYPE_DOCS_MACRO",
            Self::Analysis => "NODE_TYPE_ANALYSIS",
            Self::Operation => "NODE_TYPE_OPERATION",
            Self::Exposure => "NODE_TYPE_EXPOSURE",
            Self::Metric => "NODE_TYPE_METRIC",
            Self::SavedQuery => "NODE_TYPE_SAVED_QUERY",
            Self::SemanticModel => "NODE_TYPE_SEMANTIC_MODEL",
            Self::Function => "NODE_TYPE_FUNCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_TYPE_MODEL" => Some(Self::Model),
            "NODE_TYPE_SEED" => Some(Self::Seed),
            "NODE_TYPE_SNAPSHOT" => Some(Self::Snapshot),
            "NODE_TYPE_SOURCE" => Some(Self::Source),
            "NODE_TYPE_TEST" => Some(Self::Test),
            "NODE_TYPE_UNIT_TEST" => Some(Self::UnitTest),
            "NODE_TYPE_MACRO" => Some(Self::Macro),
            "NODE_TYPE_DOCS_MACRO" => Some(Self::DocsMacro),
            "NODE_TYPE_ANALYSIS" => Some(Self::Analysis),
            "NODE_TYPE_OPERATION" => Some(Self::Operation),
            "NODE_TYPE_EXPOSURE" => Some(Self::Exposure),
            "NODE_TYPE_METRIC" => Some(Self::Metric),
            "NODE_TYPE_SAVED_QUERY" => Some(Self::SavedQuery),
            "NODE_TYPE_SEMANTIC_MODEL" => Some(Self::SemanticModel),
            "NODE_TYPE_FUNCTION" => Some(Self::Function),
            _ => None,
        }
    }
}
/// Core outcome for any node evaluation result within any phase.
/// Represents the aggregated result of all operations in the phase
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeOutcome {
    /// Default value. Should only be set on unfinished spans
    Unspecified = 0,
    /// Successfully completed all operations in the phase.
    /// Some node types also store a type specific outcome for successful completion.
    Success = 1,
    /// Failed with an aggregated error type (individual errors reported as separate events).
    /// If set, `node_error_type` with also be set to indicate the type of error.
    Error = 2,
    /// Operation was canceled (e.g. user-initiated cancellation).
    /// If set, `node_cancel_reason` will also be set to indicate the reason for the cancelation.
    Canceled = 3,
    /// Skipped evaluation for a specific reason.
    /// If set, `node_skip_reason` will also be set to indicate the reason for the skip.
    Skipped = 4,
}
impl NodeOutcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_OUTCOME_UNSPECIFIED",
            Self::Success => "NODE_OUTCOME_SUCCESS",
            Self::Error => "NODE_OUTCOME_ERROR",
            Self::Canceled => "NODE_OUTCOME_CANCELED",
            Self::Skipped => "NODE_OUTCOME_SKIPPED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_OUTCOME_SUCCESS" => Some(Self::Success),
            "NODE_OUTCOME_ERROR" => Some(Self::Error),
            "NODE_OUTCOME_CANCELED" => Some(Self::Canceled),
            "NODE_OUTCOME_SKIPPED" => Some(Self::Skipped),
            _ => None,
        }
    }
}
/// Categorization of aggregated errors for debugging and retry logic.
/// Errors form a hierarchy: if any internal error occurred, the aggregated result is INTERNAL.
/// Otherwise if any external error occurred it is EXTERNAL. Otherwise it is USER.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeErrorType {
    /// Internal dbt error (bug, panic, unexpected state) – not recoverable by retrying.
    Internal = 0,
    /// External system error (database down, network issue, etc.) – potentially recoverable by retrying.
    External = 1,
    /// User code error (SQL syntax, compilation error, etc.) that must be fixed by the user.
    User = 2,
}
impl NodeErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Internal => "NODE_ERROR_TYPE_INTERNAL",
            Self::External => "NODE_ERROR_TYPE_EXTERNAL",
            Self::User => "NODE_ERROR_TYPE_USER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_ERROR_TYPE_INTERNAL" => Some(Self::Internal),
            "NODE_ERROR_TYPE_EXTERNAL" => Some(Self::External),
            "NODE_ERROR_TYPE_USER" => Some(Self::User),
            _ => None,
        }
    }
}
/// Reasons why a node evaluation was cabceled.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeCancelReason {
    /// User explicitly cancelled execution (e.g. ctrl-c).
    UserCancelled = 0,
}
impl NodeCancelReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UserCancelled => "NODE_CANCEL_REASON_USER_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_CANCEL_REASON_USER_CANCELLED" => Some(Self::UserCancelled),
            _ => None,
        }
    }
}
/// Reasons why a node may be skipped. Only applies to nodes selected for evaluation.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeSkipReason {
    Unspecified = 0,
    /// Skipped because an upstream dependency prevents this node from running (for any reason).
    Upstream = 1,
    /// Reused from cache
    Cached = 2,
    /// Current evaluation phase disabled for this node by configuration / flags.
    PhaseDisabled = 3,
    /// Operation had no effect (e.g. ephemeral models).
    NoOp = 4,
    /// Current evaluation phase skipped for this node due to previous phase outcome.
    PhaseSkipped = 5,
}
impl NodeSkipReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_SKIP_REASON_UNSPECIFIED",
            Self::Upstream => "NODE_SKIP_REASON_UPSTREAM",
            Self::Cached => "NODE_SKIP_REASON_CACHED",
            Self::PhaseDisabled => "NODE_SKIP_REASON_PHASE_DISABLED",
            Self::NoOp => "NODE_SKIP_REASON_NO_OP",
            Self::PhaseSkipped => "NODE_SKIP_REASON_PHASE_SKIPPED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_SKIP_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_SKIP_REASON_UPSTREAM" => Some(Self::Upstream),
            "NODE_SKIP_REASON_CACHED" => Some(Self::Cached),
            "NODE_SKIP_REASON_PHASE_DISABLED" => Some(Self::PhaseDisabled),
            "NODE_SKIP_REASON_NO_OP" => Some(Self::NoOp),
            "NODE_SKIP_REASON_PHASE_SKIPPED" => Some(Self::PhaseSkipped),
            _ => None,
        }
    }
}
/// Cache reuse classification when node_skip_reason == NODE_SKIP_REASON_CACHED.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeCacheReason {
    /// Reused from cache - no code or data changes detected.
    NoChanges = 0,
    /// Reused from cache - changes detected but still within freshness window.
    StillFresh = 1,
    /// Reused from cache - changes detected but update criteria not met.
    UpdateCriteriaNotMet = 2,
}
impl NodeCacheReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoChanges => "NODE_CACHE_REASON_NO_CHANGES",
            Self::StillFresh => "NODE_CACHE_REASON_STILL_FRESH",
            Self::UpdateCriteriaNotMet => "NODE_CACHE_REASON_UPDATE_CRITERIA_NOT_MET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_CACHE_REASON_NO_CHANGES" => Some(Self::NoChanges),
            "NODE_CACHE_REASON_STILL_FRESH" => Some(Self::StillFresh),
            "NODE_CACHE_REASON_UPDATE_CRITERIA_NOT_MET" => {
                Some(Self::UpdateCriteriaNotMet)
            }
            _ => None,
        }
    }
}
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeMaterialization {
    Unknown = 0,
    Snapshot = 1,
    Seed = 2,
    View = 3,
    Table = 4,
    Incremental = 5,
    MaterializedView = 6,
    External = 7,
    Test = 8,
    Ephemeral = 9,
    Unit = 10,
    Analysis = 11,
    /// ONLY FOR DATABRICKS
    StreamingTable = 12,
    /// ONLY FOR SNOWFLAKE
    DynamicTable = 13,
    Function = 14,
    Custom = 100,
}
impl NodeMaterialization {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "NODE_MATERIALIZATION_UNKNOWN",
            Self::Snapshot => "NODE_MATERIALIZATION_SNAPSHOT",
            Self::Seed => "NODE_MATERIALIZATION_SEED",
            Self::View => "NODE_MATERIALIZATION_VIEW",
            Self::Table => "NODE_MATERIALIZATION_TABLE",
            Self::Incremental => "NODE_MATERIALIZATION_INCREMENTAL",
            Self::MaterializedView => "NODE_MATERIALIZATION_MATERIALIZED_VIEW",
            Self::External => "NODE_MATERIALIZATION_EXTERNAL",
            Self::Test => "NODE_MATERIALIZATION_TEST",
            Self::Ephemeral => "NODE_MATERIALIZATION_EPHEMERAL",
            Self::Unit => "NODE_MATERIALIZATION_UNIT",
            Self::Analysis => "NODE_MATERIALIZATION_ANALYSIS",
            Self::StreamingTable => "NODE_MATERIALIZATION_STREAMING_TABLE",
            Self::DynamicTable => "NODE_MATERIALIZATION_DYNAMIC_TABLE",
            Self::Function => "NODE_MATERIALIZATION_FUNCTION",
            Self::Custom => "NODE_MATERIALIZATION_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_MATERIALIZATION_UNKNOWN" => Some(Self::Unknown),
            "NODE_MATERIALIZATION_SNAPSHOT" => Some(Self::Snapshot),
            "NODE_MATERIALIZATION_SEED" => Some(Self::Seed),
            "NODE_MATERIALIZATION_VIEW" => Some(Self::View),
            "NODE_MATERIALIZATION_TABLE" => Some(Self::Table),
            "NODE_MATERIALIZATION_INCREMENTAL" => Some(Self::Incremental),
            "NODE_MATERIALIZATION_MATERIALIZED_VIEW" => Some(Self::MaterializedView),
            "NODE_MATERIALIZATION_EXTERNAL" => Some(Self::External),
            "NODE_MATERIALIZATION_TEST" => Some(Self::Test),
            "NODE_MATERIALIZATION_EPHEMERAL" => Some(Self::Ephemeral),
            "NODE_MATERIALIZATION_UNIT" => Some(Self::Unit),
            "NODE_MATERIALIZATION_ANALYSIS" => Some(Self::Analysis),
            "NODE_MATERIALIZATION_STREAMING_TABLE" => Some(Self::StreamingTable),
            "NODE_MATERIALIZATION_DYNAMIC_TABLE" => Some(Self::DynamicTable),
            "NODE_MATERIALIZATION_FUNCTION" => Some(Self::Function),
            "NODE_MATERIALIZATION_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// Test-specific outcome details (only for TEST and UNITTEST node types).
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestOutcome {
    /// No failures found or below warning threshold.
    Passed = 0,
    /// Failures found between warning and error thresholds.
    Warned = 1,
    /// Failures found above error threshold.
    Failed = 2,
}
impl TestOutcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Passed => "TEST_OUTCOME_PASSED",
            Self::Warned => "TEST_OUTCOME_WARNED",
            Self::Failed => "TEST_OUTCOME_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_OUTCOME_PASSED" => Some(Self::Passed),
            "TEST_OUTCOME_WARNED" => Some(Self::Warned),
            "TEST_OUTCOME_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Freshness-specific outcome details (only for SOURCE nodes with freshness checks).
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SourceFreshnessOutcome {
    /// Freshness within acceptable (success) threshold.
    OutcomePassed = 0,
    /// Freshness exceeded warning threshold but below error threshold.
    OutcomeWarned = 1,
    /// Freshness exceeded error threshold.
    OutcomeFailed = 2,
}
impl SourceFreshnessOutcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OutcomePassed => "SOURCE_FRESHNESS_OUTCOME_OUTCOME_PASSED",
            Self::OutcomeWarned => "SOURCE_FRESHNESS_OUTCOME_OUTCOME_WARNED",
            Self::OutcomeFailed => "SOURCE_FRESHNESS_OUTCOME_OUTCOME_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOURCE_FRESHNESS_OUTCOME_OUTCOME_PASSED" => Some(Self::OutcomePassed),
            "SOURCE_FRESHNESS_OUTCOME_OUTCOME_WARNED" => Some(Self::OutcomeWarned),
            "SOURCE_FRESHNESS_OUTCOME_OUTCOME_FAILED" => Some(Self::OutcomeFailed),
            _ => None,
        }
    }
}
